---
id: ISA
aliases: 
tags:
  - Circuit
---
# ISA

## ISA Classification

| 特性分类        | 架构类型                                    | 描述                                    | 优点                         | 缺点                          | 典型例子/现代趋势                                |
| :---------- | :-------------------------------------- | :------------------------------------ | :------------------------- | :-------------------------- | :--------------------------------------- |
| **内部存储类型**  | **堆栈架构 (Stack)**                        | 操作数隐式在堆栈顶部，指令无需显式指定操作数。               | 指令紧凑，编译器设计可能相对简单。          | 内存访问开销高，随机访问困难，并行执行困难。      | 早期计算机（如 Burroughs B5000）                 |
|             | **累加器架构 (Accumulator)**                 | 一个操作数隐式为累加器，大多数 ALU 指令与累加器操作。         | 指令简单，减少显式寄存器需求。            | 累加器成为瓶颈，限制编译器优化。            | 早期计算机（如 UNIVAC I）                        |
|             | **寄存器架构 (Register)**                    | 使用通用寄存器存储操作数，所有操作数显式指定。               | 高速访问，利于编译器优化，提升并行性。        | 指令可能更长，硬件资源需求多。             | 现代主流架构                                   |
| **寄存器架构细分** | **Load-Store (或 Register-Register) 架构** | ALU 指令只操作寄存器，内存访问通过独立的 Load/Store 指令。 | 指令编码简单，固定长度，代码生成简单，执行周期相似。 | 指令数量较高，程序可能更大，影响指令缓存。       | RISC-V, ARM, MIPS, PowerPC, SPARC        |
|             | **寄存器-内存架构 (Register-Memory)**          | ALU 指令中可有一个内存操作数。                     | 无需单独 Load，指令格式紧凑，代码密度好。    | 操作数不对等，编码限制寄存器数量，每条指令周期数可变。 | Intel 80x86, IBM 360/370, Motorola 68000 |
|             | **内存-内存架构 (Memory-Memory)**             | ALU 指令中可有两个或三个内存操作数。                  | 最紧凑，不需要寄存器。                | 指令大小变化大，工作量变化大，内存访问瓶颈，现已淘汰。 | VAX                                      |


## 操作数和操作(Operands and Operations)

### 操作数类型与大小 (Type and Size of Operands)*

| 概念                     | 描述/规则                                        | 例子/细节                                                                 |
| :----------------------- | :----------------------------------------------- | :------------------------------------------------------------------------ |
| **类型指定** | 通常通过操作码 (opcode) 编码；也可数据带标签 (tags)        | 由硬件解释标签                                                              |
| **常见操作数类型** | 字符 (8位)、半字 (16位)、字 (32位)、双字 (64位)       | 单精度浮点数 (32位)、双精度浮点数 (64位)                                   |
| **整数表示** | 几乎普遍采用二进制补码 (two’s complement binary numbers)  |                                                                           |
| **字符编码** | 通常是 ASCII                                     | 16 位 Unicode (统一码) 越来越受欢迎                                       |
| **浮点标准** | 大多数计算机遵循 IEEE 754 标准 (IEEE standard 754) |                                                                           |
| **十进制格式** | 部分架构支持压缩十进制 (packed decimal) 或二进制编码的十进制 (binary-coded decimal) | 用于业务应用，精确匹配十进制数                                            |
| **字符串** | 部分架构提供字符串操作                           | 比较、移动等                                                              |
| **动态分布** | 图 A.11 (原文档图示) 显示内存访问按大小的动态分布 | 揭示不同数据类型的访问频率                                                |

### 指令集中的操作 (Operations in the ISA)*

| 操作符类别             | 描述/例子                                                              |
| :--------------------- | :--------------------------------------------------------------------- |
| **算术与逻辑** | 整数算术和逻辑操作，如加、减、与、或、乘、除                           |
| **数据传输** | 加载-存储 (Loads-stores)；内存寻址计算机上的移动指令                   |
| **控制** | 分支、跳转、过程调用和返回、陷阱                                       |
| **系统** | 操作系统调用、虚拟内存管理指令                                         |
| **浮点** | 浮点操作，如加、乘、除、比较                                           |
| **十进制** | 十进制加法、十进制乘法、十进制到字符的转换                             |
| **字符串** | 字符串移动、字符串比较、字符串搜索                                     |
| **图形** | 像素和顶点操作、压缩/解压缩操作                                        |
| **最常执行指令** | 简单操作占主导；例如，Intel 80x86 上 10 条简单指令占 96% 执行指令    |
| **应用依赖性** | 操作的变化取决于指令集包含的数据类型                                   |


### 补码 (Two's Complement)

| 概念                 | 规则                                                     | 设计原因                                                 | 例子 (8位表示)                                      |
| :------------------- | :------------------------------------------------------- | :------------------------------------------------------- | :-------------------------------------------------- |
| **定义** | 计算机中表示有符号整数的方法                             | 简化加减法运算，统一加法器实现                           | 范围 -128 到 127                                    |
| **正数规则** | 补码与原码相同                                           |                                                          | `+5` 的补码：`0000 0101`                            |
| **负数规则** | 绝对值二进制表示，按位取反，加 1                         |                                                          | `-5` 的补码：`1111 1011`                            |
| **统一加减运算** | 无需区分加减，所有运算转化为加法                         | 简化硬件设计                                             | `5 + (-5)` = `0` (`0000 0101` + `1111 1011` = `0000 0000`) |
| **消除负零** | 补码中 `0` 只有一种表示                                  | 避免 `+0` 和 `-0` 的复杂性                               |                                                     |
| **简化硬件设计** | 所有算术运算归结为加法，硬件简洁高效                     |                                                          | `7 - 3` (即 `7 + (-3)`) = `4` (`0000 0111` + `1111 1101` = `0000 0100`) |

### 浮点标准 (IEEE 754 Standard)

| 概念         | 定义                                                     | 目的                                                     | 主要内容                                                                                   | 重要性                                                     |
| :----------- | :------------------------------------------------------- | :------------------------------------------------------- | :----------------------------------------------------------------------------------------- | :--------------------------------------------------------- |
| **IEEE 754 标准** | 电气和电子工程师协会发布的浮点数表示和算术运算技术标准   | 实现浮点数计算的跨平台一致性，避免结果不一致             | **浮点数格式** (单精度、双精度、符号位、指数、尾数)；**舍入规则**；**操作**；**异常处理** (NaN, Infinity) | 确保浮点数计算的可移植性 (portability) 和可靠性 (reliability) |

# Registers

## RISC-V Registers

- *整数寄存器*是**32位宽**，*浮点寄存器*可以是**32/64位宽**

| Register | ABI (Application Binary Interface) Name | Use | Saver |
| :--- | :--- | :--- | :--- |
| `x0` | `zero` | The constant value 0 | N.A. |
| `x1` | `ra` | Return address | Caller |
| `x2` | `sp` | Stack pointer, 始终指向栈顶 | Callee |
| `x3` | `gp` | Global pointer | — |
| `x4` | `tp` | Thread pointer | — |
| `x5-x7` | `t0-t2` | Temporaries | Caller |
| `x8` | `s0/fp` | Saved register/frame pointer, 函数可能调用它，此时为fp, 否则就是s0。但返回前必须恢复该寄存器。fp始终指向基址，这样更容易定位栈中的变量| Callee |
| `x9` | `s1` | Saved register | Callee |
| `x10-x11`| `a0-a1` | Function arguments/return values| Caller |
| `x12-x17`| `a2-a7` | Function arguments | Caller |
| `x18-x27`| `s2-s11`| Saved registers | Callee |
| `x28-x31`| `t3-t6` | Temporaries | Caller |
| `f0-f7` | `ft0-ft7` | FP temporaries | Caller |
| `f8-f9` | `fs0-fs1` | FP saved registers | Callee |
| `f10-f11`| `fa0-fa1` | FP function arguments/return values| Caller |
| `f12-f17`| `fa2-fa7` | FP function arguments | Caller |
| `f18-f27`| `fs2-fs11`| FP saved registers | Callee |
| `f28-f31`| `ft8-ft11`| FP temporaries | Caller |


## 寻址简介和跳转

| Concept | Core Summary | Key Details & Example |
| :--- | :--- | :--- |
| **基于缩放变址的寻址** (Based with Scaled Index) | 高效计算内存地址，尤其用于数组访问，由AGU(Adress Generation Units)直接通过硬件执行 (向左移位即可) | **公式**: $\text{Effective Address} = \text{Base} + (\text{Index} \times \text{Scale}) + \text{Displacement}$ `Base` 为数组首地址, `Index` 为 `i`, `Scale` 为单个元素大小(1, 2, 4, 8)。 |
| **PC 相对寻址** (PC-relative addressing) | 动态计算跳转的目标地址 | **公式**: $\text{Target Address} = \text{Current PC} + \text{Offset}$ **优点**: 生成**位置无关代码 (Position-Independent Code)** |
| **条件分支** (Conditional Branch) | 根据某个运算结果的标志位 (如零标志、负标志) 来决定是否执行跳转。若条件满足，则跳转；否则顺序执行。 | **用途**: 实现 `if-else`, `for`, `while` 等控制流结构。**寻址**: 通常使用 PC 相对寻址，因为跳转范围一般较小。 |
| **无条件跳转** (Unconditional Jump) | 不检查任何条件，直接、强制性地跳转到目标地址。 | **用途**: 实现 `goto` 或组织代码块的跳转。**寻址**: 短距离跳转使用 PC 相对寻址；长距离跳转或跨段跳转可能使用绝对地址。 |
| **过程调用** (Procedure Call) | 跳转到子程序(函数)，并在跳转前将**返回地址**(调用指令的下一条指令地址)保存到栈或链接寄存器中。 | **用途**: 实现函数调用。**寻址**: 目标函数地址通常使用 PC 相对寻址计算|
| **过程返回**  (Return) | 从子程序返回到调用者。 | **机制**: 从栈或链接寄存器中取出之前保存的返回地址，并将其加载回程序计数器 (PC)。**寻址**: 其目标地址是**调用时保存的地址**，而非通过 PC 相对寻址计算。 |


## 过程调用 (Procedure Calls) 与返回 (Returns)

| 概念                     | 描述                                                                                                                                                                                                                                     | RISC-V 示例指令                                                                                                                               |
| :----------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------- |
| **过程调用 (Procedure Calls)** | 当一个程序调用子程序或函数时执行。涉及保存返回地址、传递参数和转移控制流到被调用过程。                                                                                                                                               | `jal` (Jump and Link)：将下一条指令的地址保存到指定寄存器（如 `ra` 寄存器 `x1`），然后跳转到目标地址。                                       |
| **过程返回 (Procedure Returns)** | 被调用过程执行完毕后，将控制流返回给调用者。涉及恢复调用者状态、返回结果（如果适用）和恢复控制流到调用点之后。                                                                                                                             | `jalr` (Jump and Link Register)：通常用于间接跳转。当目标寄存器设置为 `x0`（零寄存器）时，可实现从过程返回到调用点。                      |
| **寄存器保存约定** | 确保过程调用和返回时寄存器内容正确保存和恢复的约定。                                                                                                                                                                                     | **调用者保存 (Caller Saving)**：调用者在调用前保存其后续会使用的寄存器内容。<br>**被调用者保存 (Callee Saving)**：被调用者在入口处保存并退出前恢复调用者可能使用的寄存器内容。ABI (Application Binary Interface) 规定了具体哪些寄存器由谁保存。 |


## 指令集编码 (Instruction Set Encoding)

| 编码类型             | 特点                                                                                                 | 优点                                                                                     | 缺点                                                                                         | 典型实例              |
| :------------------- | :--------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------- | :-------------------- |
| **可变长度编码 (Variable Length Encoding)** | 指令长度不固定，根据指令操作和操作数数量而变化。                                                     | - 高代码密度 (Code Density)，节省内存空间。<br>- 灵活，允许所有寻址模式与所有操作结合。 | - 处理器解码复杂，需要先确定指令长度，可能影响流水线效率。                                   | Intel x86 架构        |
| **固定长度编码 (Fixed Length Encoding)** | 所有指令都具有相同的长度。                                                                           | - 简化指令取指和解码过程，有助于高效流水线设计。<br>- 硬件实现相对简单。                   | - 代码密度较低，简单指令可能无法充分利用所有位，造成空间浪费。                               | RISC-V、MIPS、ARM (通常) |
| **混合编码 (Hybrid Encoding)** | 结合了可变长度和固定长度的特点，通过操作码指定多种格式和长度。例如，部分指令为短固定长度，部分为长固定长度。 | - 在保持处理器解码相对简单的前提下，显著提高代码密度。<br>- 适用于对代码大小有严格限制的系统。 | - 比纯粹的固定长度编码略复杂，处理器需要判断指令长度。                                       | RISC-V 的压缩指令集扩展 (Compressed Instruction Set Extension, C) |


### 流水线 (Pipelining) 解释

| 概念     | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **定义** | 流水线是一种计算机处理器技术，通过将指令的执行过程分解成多个独立的阶段，并让不同的指令在这些不同的阶段上同时进行，从而实现多条指令的并行处理，提高指令吞吐量 (instruction throughput)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| **工作原理** | 类似于工厂的装配线。例如，一条指令的执行过程可能包括：<br>1. **取指令 (Instruction Fetch, IF)**：从内存中读取指令。<br>2. **译码 (Instruction Decode, ID)**：解析指令，确定操作类型和操作数。<br>3. **执行 (Execute, EX)**：执行指令指定的操作（如算术逻辑运算）。<br>4. **访存 (Memory Access, MEM)**：如果需要，访问内存（加载数据或存储数据）。<br>5. **写回 (Write Back, WB)**：将结果写回寄存器或内存。<br>当指令A处于执行阶段时，指令B可以处于译码阶段，指令C可以处于取指令阶段，从而实现并行处理。                                                                                                                                                                                                                                                                                                                                                                                                                             |
| **目的** | 提高处理器**吞吐量 (Throughput)**：单位时间内完成的指令总数增加。<br>虽然单条指令的**延迟 (Latency)**（完成一条指令所需的时间）可能不变甚至略有增加（由于阶段间的额外开销），但流水线显著提升了整体性能。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **优点** | 显著提高处理器性能，使得处理器在相同频率下能处理更多指令。<br>更高效地利用硬件资源，使得处理器能够同时处理多条指令的不同部分。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **挑战** | **冒险 (Hazards)**：包括结构冒险（硬件资源冲突）、数据冒险（指令间数据依赖）和控制冒险（分支指令导致的不确定性）。处理器需要机制（如转发、停顿、分支预测）来解决这些问题。<br>**流水线深度**：流水线阶段越多，理论上吞吐量越高，但同时冒险处理的复杂性和停顿的开销也会增加。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

---

### x86 vs RISC-V 指令编码差异

| 特性           | x86 指令集架构 (ISA)                                                     | RISC-V 指令集架构 (ISA)                                                  |
| :------------- | :----------------------------------------------------------------------- | :--------------------------------------------------------------------- |
| **设计哲学** | **复杂指令集计算机 (CISC)**：指令功能复杂，旨在减少指令条数。                 | **精简指令集计算机 (RISC)**：指令简单规则，旨在高效硬件实现和流水线。         |
| **指令长度** | **变长编码 (Variable-length encoding)**：1字节到15字节不等。                   | **固定长度编码 (Fixed-length encoding)**：基础指令通常是32位（4字节）。可选16位压缩指令。 |
| **历史背景** | 1970年代末期，内存受限，编译器不成熟。主要为了**减小程序大小 (Code size reduction)**。 | 2010年以后设计，现代架构，内存充足，编译器成熟。主要为了**高效流水线处理 (Efficient pipelining)**。 |
| **流水线影响** | **复杂译码**：处理器需先确定指令长度，可能成为流水线瓶颈。现代x86内部转换为类似RISC的微操作。 | **简化取指和译码**：处理器可一次性取固定长度数据，快速译码，简化流水线设计，提高效率。 |
| **代码密度** | 通常提供更好的**代码密度 (Code density)**，即占用存储空间更小。                 | 基础指令代码密度略低，但可通过**压缩指令集 (C-extension)** 显著提高代码密度。 |
| **主要优势** | 节省内存空间（早期），兼容性强。                                         | 简化硬件实现，高效流水线，能耗效率高，开放免费。                             |
| **主要挑战** | 指令译码复杂，流水线设计难度大。                                         | 早期代码密度略低（已被C-extension改善）。                                  |
