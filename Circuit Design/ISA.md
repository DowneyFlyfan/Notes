---
id: ISA
aliases: []
tags:
  - Circuit
---
# ISA

## Classification

| 特性分类        | 架构类型                                    | 描述                                    | 优点                         | 缺点                          | 典型例子/现代趋势                                |
| :---------- | :-------------------------------------- | :------------------------------------ | :------------------------- | :-------------------------- | :--------------------------------------- |
| **内部存储类型**  | **堆栈架构 (Stack)**                        | 操作数隐式在堆栈顶部，指令无需显式指定操作数。               | 指令紧凑，编译器设计可能相对简单。          | 内存访问开销高，随机访问困难，并行执行困难。      | 早期计算机（如 Burroughs B5000）                 |
|             | **累加器架构 (Accumulator)**                 | 一个操作数隐式为累加器，大多数 ALU 指令与累加器操作。         | 指令简单，减少显式寄存器需求。            | 累加器成为瓶颈，限制编译器优化。            | 早期计算机（如 UNIVAC I）                        |
|             | **寄存器架构 (Register)**                    | 使用通用寄存器存储操作数，所有操作数显式指定。               | 高速访问，利于编译器优化，提升并行性。        | 指令可能更长，硬件资源需求多。             | 现代主流架构                                   |
| **寄存器架构细分** | **Load-Store (或 Register-Register) 架构** | ALU 指令只操作寄存器，内存访问通过独立的 Load/Store 指令。 | 指令编码简单，固定长度，代码生成简单，执行周期相似。 | 指令数量较高，程序可能更大，影响指令缓存。       | RISC-V, ARM, MIPS, PowerPC, SPARC        |
|             | **寄存器-内存架构 (Register-Memory)**          | ALU 指令中可有一个内存操作数。                     | 无需单独 Load，指令格式紧凑，代码密度好。    | 操作数不对等，编码限制寄存器数量，每条指令周期数可变。 | Intel 80x86, IBM 360/370, Motorola 68000 |
|             | **内存-内存架构 (Memory-Memory)**             | ALU 指令中可有两个或三个内存操作数。                  | 最紧凑，不需要寄存器。                | 指令大小变化大，工作量变化大，内存访问瓶颈，现已淘汰。 | VAX                                      |

## 💻RISC-V 基础整数指令集（RV32I/RV64I）

| 类别 | 助记符 | 格式 | 描述 |
| :--- | :--- | :--- | :--- |
| **算术/逻辑** | `ADD` | R | 寄存器加法：`rd = rs1 + rs2` |
| | `ADDI` | I | 立即数加法：`rd = rs1 + imm` |
| | `SUB` | R | 寄存器减法：`rd = rs1 - rs2` |
| | `LUI` | U | 载入高位立即数：`rd = imm << 12` |
| | `AUIPC` | U | PC相对高位立即数：`rd = pc + (imm << 12)` |
| | `AND` | R | 逻辑与：`rd = rs1 & rs2` |
| | `ANDI` | I | 立即数逻辑与：`rd = rs1 & imm` |
| | `OR` | R | 逻辑或：`rd = rs1 \| rs2` |
| | `ORI` | I | 立即数逻辑或：`rd = rs1 \| imm` |
| | `XOR` | R | 逻辑异或：`rd = rs1 ^ rs2` |
| | `XORI` | I | 立即数逻辑异或：`rd = rs1 ^ imm` |
| **移位** | `SLL` | R | 逻辑左移：`rd = rs1 << rs2` |
| | `SLLI` | I | 立即数逻辑左移：`rd = rs1 << imm` |
| | `SRL` | R | 逻辑右移：`rd = rs1 >> rs2` |
| | `SRLI` | I | 立即数逻辑右移：`rd = rs1 >> imm` |
| | `SRA` | R | 算术右移：`rd = rs1 >>> rs2` |
| | `SRAI` | I | 立即数算术右移：`rd = rs1 >>> imm` |
| **比较** | `SLT` | R | 小于则置位（有符号）：`rd = (rs1 < rs2) ? 1 : 0` |
| | `SLTI` | I | 立即数小于则置位（有符号）：`rd = (rs1 < imm) ? 1 : 0` |
| | `SLTU` | R | 小于则置位（无符号）：`rd = (rs1 < rs2) ? 1 : 0` |
| | `SLTIU` | I | 立即数小于则置位（无符号）：`rd = (rs1 < imm) ? 1 : 0` |
| **内存访问** | `LB` | I | 载入字节（有符号）：`rd = MEM[rs1 + imm]` |
| | `LH` | I | 载入半字（有符号）：`rd = MEM[rs1 + imm]` |
| | `LW` | I | 载入字（有符号）：`rd = MEM[rs1 + imm]` |
| | `LBU` | I | 载入字节（无符号）：`rd = MEM[rs1 + imm]` |
| | `LHU` | I | 载入半字（无符号）：`rd = MEM[rs1 + imm]` |
| | `SB` | S | 存储字节：`MEM[rs1 + imm] = rs2` |
| | `SH` | S | 存储半字：`MEM[rs1 + imm] = rs2` |
| | `SW` | S | 存储字：`MEM[rs1 + imm] = rs2` |
| **控制流** | `BEQ` | B | 相等则分支：`if (rs1 == rs2) pc += imm` |
| | `BNE` | B | 不相等则分支：`if (rs1 != rs2) pc += imm` |
| | `BLT` | B | 小于则分支（有符号）：`if (rs1 < rs2) pc += imm` |
| | `BGE` | B | 大于等于则分支（有符号）：`if (rs1 >= rs2) pc += imm` |
| | `BLTU` | B | 小于则分支（无符号）：`if (rs1 < rs2) pc += imm` |
| | `BGEU` | B | 大于等于则分支（无符号）：`if (rs1 >= rs2) pc += imm` |
| | `JAL` | J | 跳转并链接：`rd = pc + 4; pc += imm` |
| | `JALR` | I | 间接跳转并链接：`rd = pc + 4; pc = (rs1 + imm) & ~1` |
| **系统** | `FENCE` | I | 内存屏障 |
| | `ECALL` | I | 环境调用/系统调用 |
| | `EBREAK` | I | 断点/调试器调用 |

---

## 🛠️常用标准扩展（Extensions）

| 扩展字母 | 名称 | 描述 | 主要指令示例 |
| :--- | :--- | :--- | :--- |
| **M** | **整数乘除法** | 提供硬件乘法和除法指令，提高性能 | `MUL`, `DIV`, `REM` |
| **A** | **原子操作** | 支持多处理器环境下的原子内存操作 | `AMOADD.W`, `LR.W`, `SC.W` |
| **F** | **单精度浮点** | 增加32位浮点寄存器和单精度浮点运算指令 | `FLW`, `FADD.S`, `FMUL.S` |
| **D** | **双精度浮点** | 增加双精度浮点寄存器和双精度浮点运算指令 | `FLD`, `FADD.D`, `FMUL.D` |
| **C** | **压缩指令集** | 提供16位指令格式，用于提高代码密度 | `C.ADDI`, `C.LW`, `C.J` |
| **V** | **向量指令集** | 专为大规模数据并行操作设计的向量指令 | `VADD.VV`, `VLOAD`, `VSTORE` |

## Others

- lw/sw: load/store words

- nop (no operation)

- #: Immediate Number

# 操作数和操作(Operands and Operations)

## 浮点标准 (IEEE 754 Standard)

| 概念         | 定义                                                     | 目的                                                     | 主要内容                                                                                   | 重要性                                                     |
| :----------- | :------------------------------------------------------- | :------------------------------------------------------- | :----------------------------------------------------------------------------------------- | :--------------------------------------------------------- |
| **IEEE 754 标准** | 电气和电子工程师协会发布的浮点数表示和算术运算技术标准   | 实现浮点数计算的跨平台一致性，避免结果不一致             | **浮点数格式** (单精度、双精度、符号位、指数、尾数)；**舍入规则**；**操作**；**异常处理** (NaN, Infinity) | 确保浮点数计算的可移植性 (portability) 和可靠性 (reliability) |
