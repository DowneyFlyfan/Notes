---
id: Verilog_Basics
aliases: []
tags:
  - Circuit
---

# 概念

## 名称概念

| Term/Concept               | Description                                                                                                                              |
| :------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------- |
| xDC                        | eXtensible Device Description                                                                                                            |
| RTL                        | Register-Transfer Level                                                                                                                  |
| 低电平复位                 | 是常用的做法，因为**上拉电阻**处于高电平状态(下拉电阻没电了没法接收信号!), 另外VCC没有GND抗噪声                                           |
| High Impedance($Z$)        | 表示该信号没有被其他信号驱动，是为了防止多个设备同时和总线通讯                                                                                                         |
| Unknown(Don't Care)($X$)   | 在`!==`中可以被视为第3、4种逻辑状态；Unknown会导致调试时难以区分是否正确；Don't Care会使得在综合时可以综合出效率更高的电路；多个设备同时写一根线时发生矛盾 |

## 不同编码

| 特性     | 独热码 (One-Hot)                     | 二进制码 (Binary)          |
| :------- | :----------------------------------- | :------------------------- |
| **优点** | 速度快、逻辑简单、适合FPGA结构、功耗低 | 触发器（FF）占用最少       |
| **缺点** | 触发器（FF）占用较多                 | 组合逻辑复杂、速度较慢、可能存在竞争冒险 |

- DUT: Device Under Test

- SystemC: C++的扩展版，主要用于EDA

- XML: eXtensible Markup Language, 描述网格和列表的标签语言

# 组合逻辑与时序逻辑

## 不同的赋值方式

| 特性         | 过程赋值: 非阻塞赋值 (<=)                                | 过程赋值: 阻塞赋值 (=)                                     | 连续赋值 (assign)                          |
| :----------- | :--------------------------------------------- | :----------------------------------------------- | :----------------------------------------- |
| 描述逻辑类型 | 时序逻辑                                       | 组合逻辑                                         | 组合逻辑                                   |
| 使用位置     | 只能在always等过程块内部                       | 只能在always等过程块内部                         | 只能在always等过程块外部                   |
| 执行方式     | 并行执行: 上升沿采样, 然后赋值 | 顺序执行 |并行执行: 右值一变就**立刻**赋值 |
| 综合电路     | 带时钟的触发器、寄存器                         | 不带时钟的逻辑门、连线                           | 不带时钟的逻辑门、连线                     |
| 推荐用途     | always @(posedge clk)                          | always @(*)                                      |  |

## 差别

- 组合逻辑: 没有记忆，没有反馈回路, 单向信号一次通过，异步 (赋值时只要右边一变，左边就立即被赋值)

- 时序逻辑: 有记忆，有反馈回路，像状态机, 同步

# 语法

## 经验

| Feature                              | Description                                                                                             |
| :----------------------------------- | :------------------------------------------------------------------------------------------------------ |
| `,`                                  | 在 **List** 中使用, `;` 在其他地方使用                                                                  |
| `{}` 拼接操作符                      | 比如 `{4'b1111, bias[0]}` 会把两个数拼接起来，若bias是8位数，就会拼成12位数                           |
| `generate` 模块                      | 用来将变量用 **实际导线连接起来**                                                                       |
| `genvar`                             | 生成只能在 `generate` 块使用的变量                                                                      |
| `[MSB-1:0] A`                        | 定义了该变量从高位存储到低位，取值时 `A[MSB-1]` 依然表示最高位值                                        |
| `[start_bit:+add_bit]`               | 只会取 `add_bit` 位                                                                                     |
| `begin` 后模块名                     | 可以给这个模块加一个模块名，以增加可读性                                                                |
| `always_ff`, `always_comb`, `always` | 都是 `always` 块的不同变体                                                                              |
| `always` 和 `initial` 块             | 所有的 `always` 和 `initial` 块都是并行执行的                                                           |
| 位选择方向                           | 必须和声明信号时定义的方向一致                                                                          |
| 向量和数组切片                       | 只有向量可以切片，数组不能切片                                                                          |
| 有符号数位数                         | 有符号数一定要比原来的无符号数多一位!                                                                   |
| 向量和数组赋值                       | 向量可以直接赋值，数组必须用循环赋值                                                                    |
| `localparam`                         | 只能在当前的 `begin - end` 之内使用, 不会成为电路实体                                                                     |
| 有符号数显式补位                     | 有符号数赋值给另一个高位有符号数要显式补位 `adder_tree_data <= signed'(din[(adder+1)*IN_WIDTH-1-:IN_WIDTH]);` **signed并不会对无符号数补0，而是会将其直接解释为有符号数**!!|
| 变量声明 | 必须位于`always` 或 `initial` 的开头 |
|`parameter`|必须在`#()`中定义好，不能放到`localparam`里定义|

- 从`X`到`0`或`1`也被视为上升沿或下降沿

- 同一个`initial`块内的语句是串行执行的，多个`initial`块之间是并行执行的

- `generate`块不能连太多的电路，否则无法综合

- `integar`是32位无符号整数, `real`默认为0，赋值给`integar`只会取整数部分

- `str`: 一个字符长度是8位(1字节), 太长从高位截断，太短高位补0

- `parameter`可以改， `localparam`不可以改

- `wire`

- 负数初始化一定要指定位宽

- 全等可以比`X`, 逻辑相等不能比`X`

| &(与) | 0 | 1 | x | |(或) | 0 | 1 | x |
|---|---|---|---|---|---|---|---|---|
| 0 | 0 | 0 | 0 | | 0 | 0 | 1 | x |
| 1 | 0 | 1 | x | | 1 | 1 | 1 | 1 |
| x | 0 | x | x | | x | x | 1 | x |

| ^(异或) | 0 | 1 | x | | ~^(同或) | 0 | 1 | x |
|---|---|---|---|---|---|---|---|---|
| 0 | 0 | 1 | x | | 0 | 1 | 0 | x |
| 1 | 1 | 0 | x | | 1 | 0 | 1 | x |
| x | x | x | x | | x | x | x | x |


- 如果一个设计中的多个模块都带有 `timescale 时，模拟器总是定位在所有模块的最小时延精度上

- `default_nettype 类型名` 为隐式的线网变量指定类型

- 缺省连线类型指的是未定义类型的`input`和`output`

- 时延:`wire #10 Z = A&B`，那么任何时候`Z`都会在`A,B`变化后的10个时间单位之后才被赋值; 所有时延都是仿真语句，不会被综合成电路

- 惯性时延: 如果在10个时间单位内，`A,B`又变化了，那么`Z`的赋值结果会采用`A,B`的新值进行计算

- `fork ... join`块内部的语句并行执行

- 命名块之后，块中变量可被其他模块访问`module.block.variable`

- `casex` 和 `casez` 分别用`x` 和 `?`来表示无关项，但是只用于仿真，不可综合

- `forever` 和 `while(1)` 等价

| 端口类型 | 模块内部 (Module) | 模块例时 (Module) | 任务内部 (Task) | 任务行为描述 (Task)                            |
| :------- | :---------------- | :------------------ | :-------------- | :--------------------------------------------- |
| `input`  | `wire`            | `wire`或`reg`       | `reg`或`wire`   | 只能接收值，在task执行期间值不变。             |
| `output` | `wire`或`reg`     | `wire`              | `reg`           | 必须是reg，因为task内部需要对其赋值。          |
| `inout`  | `wire`            | `wire`              | `wire`          | 必须是wire，因为它需要能够驱动和接收数据。     |


- 层次访问一般在仿真中进行

- 例化时位宽不匹配，**输入位宽多直接截位，输入位宽低则高位补`z`**

- `function 位宽 function_id input(...)`, function_id就是返回值(只有一个), input可以有很多

- `automatic`可以对调用的`function`或者`task`进行动态分配，这样就不会出现多个调用抢一个`function`的硬件资源的情况

- **无符号数最好不要相减**，否则会溢出!!!

## SV和Verilog的区别


| 特性       | `always_ff` (SystemVerilog)                                                                                                                              | `always` (传统 Verilog)                                                     |
| :--------- | :------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------- |
| **意图**   | **非常明确**: 只用于时序逻辑 (Flip-Flops)。                                                                                                              | **模糊**: 可用于时序、组合逻辑或锁存器，容易混淆。                          |
| **语法**   | **更严格**: 工具会检查块内是否只包含合法的时序逻辑代码（例如，必须使用非阻塞赋值）。如果敏感列表不符合时序逻辑的规范（如缺少时钟或复位信号），工具会发出警告或错误。 | **宽松**: 语法检查不那么严格，容易意外地写出锁存器（latch）或其他不期望的硬件。 |
| **可读性** | **高**: 任何人看到 `always_ff` 都立刻知道这是在定义一组寄存器。                                                                                          | **中**: 需要仔细查看敏感列表 (`@(...)`) 和内部的赋值语句才能判断其真正意图。 |
| **推荐**   | **强烈推荐** 用于所有新的 SystemVerilog 设计中描述时序逻辑。                                                                                           | 在新的设计中应尽量用 `always_ff`, `always_comb` 替代。                      |

# 综合工具

- 时钟信号、时序逻辑下的移位寄存器等 被综合成 FlipFlops

- 加法、乘法等可以存储成逻辑判断结果放在LUT单元里

- 时序逻辑的直接的加减乘除 大概率被综合成DSP单元执行

- reg综合 与 RAM类型

- **Source Clock Delay**(SCD) 和 **Destination Clock Delay**(DCD) 指的分别是时钟信号到达源寄存器和目标寄存器的时间

- setup和hold 时间余量 $T_{slack} = T_{clock} + T_{DCD} - T_{SCD} - T_{delay} - T_{setup/hold}$

- **生成的数组中的多余部分都会被综合工具自动remove**

| 类型/描述          | Verilog 描述 (`reg`)               | 推断条件                                    | 综合成的物理资源                      | RAM类型    | 端口数量 | 关键特性                   | 核心优势                             |
| :----------------- | :--------------------------------- | :------------------------------------------ | :------------------------------------ | :--------- | :------- | :------------------------- | :----------------------------------- |
| `reg` 推断         | `reg [N-1:0] my_reg;`              | 单个向量，用于在时钟周期内保持状态或数据。  | **N个触发器 (Flip-Flops)**          |            |          |                            |                                      |
| `reg` 推断         | `reg [W-1:0] mem [D-1:0];`         | **大型**、规整的二维数组，同步读写。        | **块RAM (Block RAM)**               |            |          |                            |                                      |
| `reg` 推断         | `reg [W-1:0] small_mem [S-1:0];`   | **小型**二维数组，或访问模式不符合BRAM。    | **W x S 个触发器 (构成分布式RAM)**    |            |          |                            |                                      |
| BRAM 类型          |                                    |                                             |                                       | 单端口     | 1个      | 同一时间只能读或写         | 简单                                 |
| BRAM 类型          |                                    |                                             |                                       | 简单双端口 | 2个      | 1个只读，1个只写           | 可以同时进行一次读和一次写           |
| BRAM 类型          |                                    |                                             |                                       | **真双端口** | **2个**  | **每个端口都能独立进行读写** | **极高的灵活性和并行性，是数据交互的利器** |

# 其他

- `.core`文件是用类似`yaml`的格式描述其当前核的依赖、目标、目标参数等的文件

- `.s`是汇编文件
